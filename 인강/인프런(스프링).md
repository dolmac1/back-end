# 스프링 핵심원리 - 기본편
## 1-1. 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생
- EJB는 예전에 금융권같은데서 표준으로 많이 도입함.
- EJB는 분산에 대한 지원이 잘되었었음
- JPA는 ORM 기술, EJB는 Entity bin 이라는 orm 기술을 가지고 있었음
- ORM기술은 쿼리 안쓰고 DB에 접근해서 데이터 넣고빼고
- 근데 EJB는 이론적으로 굉장히 좋으나 비쌈
- 심지어 복잡한데 어렵고 EJB에 의존적으로 개발해야하는 치명적인 단점이 있음(지옥임)
- EJB는 컨테이너 하나 띄우는데도 시간 엄청 오래걸림
- EJB가 너무 개떡같았기 때문에 POJO로 돌아가자라는 소리까지 나옴
- 그래서 만들어진 것이 스프링이다
- EJB의 엔티티빈이 너무 꾸져서 하이버네이트를 만들었는데 이것이 자바 표준을 만드는 곳에서 하이버네이트를 가지고 JPA를 만들었음
- JPA가 자바 진형의 ORM을 다 먹고있음
- JPA는 실용성과 표준의 안정성을 만족 시킬 수 있게되었음
### 스프링의 역사
- 2002년 로드 존슨이 EJB의 문제점을 지적하면서 EJB없이도 충분히 고품질의 확장 가능한 애플리케이션을 3만라인 이상의 기반 코드를 보여줌으로써 혁신을 일으킴(스프링의 시작)
- 로드 존슨에게 유겐휠러와 얀 카로프가 스프링 오픈소스 프로젝트를 제안했고, 스프링의 핵심 코드는 현재도 유겐 휠러가 개발 중
- 스프링의 뜻은 J2EE(EJB)라는 겨울을 넘어 새로운 시작이라는 뜻으로 지음
- 스프링 릴리즈 역사
    - 2003년 스프링 프레임워크 1.0 출시 - XML
    - 2006년 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원
    - 2009년 스프링 프레임워크 3.0 출시 - 자바 코드로 설정
    - 2013년 스프링 프레임워크 4.0 출시 - 자바 8
    - 2014년 스프링 부트 1.0 출시 - 설정이 너무 어려운 스프링의 단점을 개선, 설정을 거의 할 필요없고 서버도 내장
    - 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 - 리엑티브 프로그래밍 지원
    - 현재 진행 중

## 1-2. 스프링이란
### 스프링 생태계
- 스프링 프레임워크, 스프링 부트, 스프링 데이터(데이터베이스 쉽게 접근), 스프링 세션(세션관련), 스프링 시큐리티(보안), 스프링 REST DOCS, 스프링 배치(배치처리에 특화된 기술), 스프링 클라우드(클라우드 관련 기술)
- spring.io에 프로젝트 오버뷰를 보면 어떤 기술이 무슨 역할을 하는지 다 나와있음
### 스프링 프레임워크
- 핵심기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹기술 : 스프링 MVC, 스프링 WebFlux 
- 등등
- 핵심기술에 초점을 맞춰서 강의 할 것
### 스프링 부트
- 단독으로 실행할 수 있는 스프링 어플리케이션을 쉽게 생성
- tomcat 같은 웹 서버를 내장해서 별도 웹 서버 설치 안해도 됌
- 손쉬운 빌드 구성을 위한 starter 종속성 제공(라이브러리 쓸때 필요한걸 starter가 알아서 다 땡겨와줌)
- 스프링과 3rd parth 라이브러리 자동 구성(메이저 라이브러리는 어떤게 지금 스프링 버전에 맞는지 알아서 다 챙겨줌)
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공(모니터링 화면 제공)
- 관례에 의한 간결한 설정(꼭 필요할 때에만 설정을 바꿈)
- 스프링 부트는 기본적으로 스프링 프레임워크를 가져와서 해주는 거지 껍데기라 혼자서는 동작 불가
### 스프링 단어
- 스프링이라는 단어는 문맥에 따라 다르게 사용된다.
    - 스프링 DI 컨테이너 기술
    - 스프링 프레임워크
    - 스프링 부트, 스프링 프레임워크 등을 모두 포함하는 포괄적인 단어
### 스프링은 왜 만들었나
- 핵심 개념을 알아야 배우기 쉬움
- 스프링의 핵심 개념, 컨셉?
    - 웹 앱을 만들고 DB 접근 편리하게 해주는 기술인가?
    - 전자정부 프레임워크?
    - ???
- 스프링의 진짜 핵심
    - 스프링은 자바 기반의 프레임워크
    - 자바 언어의 가장 큰 특징 - 객체 지향 언어적 장점을 살려서 개발 할 수 있도록 도와줌
    - 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
    - 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와주는 프레임워크 !!

## 1-3 좋은 객체지향 프로그래밍이란?
### 객체 지향 프로그래밍
- 컴퓨터 프로그램을 객체들의 모임으로 파악하고 그에 맞게 개발
- 객체지향 프로그래밍은 유연하고 변경이 용이하게 만듬
- 객체간에 메시지를 주고받고 서로 협력함
- 유연하고 변경이 용이하다?
    - 레고 블럭 조립하듯
    - 키보드 마우스를 갈아끼우듯
    - 다형성이 핵심이라고 보면 된다
### 다형성
- 다형성의 실세계 비유
    - 실세계와 객체지향을 1:1로 매칭X
    - 역할과 구현으로
- 운전자 - 자동차
    - 자동차가 K3에서 아반떼로 바뀌어도 운전자는 운전할 수 있다(자동차가 바뀌어도 운전자에게 영향을 미치지 않는다)
    - 운전자는 자동차 역할(인터페이스)에 대해서만 알고 자동차 구현(차종)은 모름
    - 다른 대상으로 변환이 가능하고 새로운 것이 나와도 영향을 미치지 않음(클라이언트에 영향을 주지 않고 새로운 기능을 제공 가능)
- 새로운 기능이 나와도 클라이언트를 바꿀 필요가 없다! 이게 제일 중요함
- 공연 무대
    - 로미오 역할과 줄리엣 역할이 있다
    - 이 로미오 역할을 장동건이 할수도 원빈이 할수도 있고, 줄리엣 역할은 김태희가 할수도 있고 송혜교가 할수도 있다
    - 역할을 하는 사람은 바뀌어도 상관 없음
    - 역할과 구현이 따로 분리되어있음!
### 역할과 구현을 분리
- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경이 편해짐
- 장점
    - 클라이언트는 대상의 역할(인터페이스)만 알면 된다
    - 클라이언트는 내부 구조를 몰라도 된다
    - 클라이언트는 내부 구조가 변경되도 영향을 받지 않음
    - 클라이언트는 구현 대상 자체가 변경되도 영향을 받지 않음
- 자바언어의 다형성을 활용
    - 역할 = 인터페이스
    - 구현 = 인터페이스를 구현한 클래스, 구현 객체
    - 객체를 설계할 때 역할과 구현을 명확히 분리
    - 객체 설계시 인터페이스를 먼저 부여하고 구현
### 객체의 협력이라는 관계부터 생각
- 혼자 있는 객체는 없음
- 클라이언트는 요청, 서버는 응답
- 수많은 객체 클라이언트와 서버가 서로 협력관계를 가짐
- 클라이언트는 서버가 될수도 있음
### 자바 언어의 다형성
- 오버라이딩을 떠올려보자
    - 오버라이딩은 자바 기본 문법
    - 오버라이딩 된 메서드가 실행
    - 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능
    - 클래스 상속 관계에서도 다형성, 오버라이딩 삽가능
- 예시
    - 클라이언트가 멤버Repository를 사용한다고 할때 다형성을 이용하여 memory memberrepository의 기능을 쓸수도 있고 jdbc memberrepository 사용 가능
    - 클라이언트가 서버의 a기능을 호출할 수도 있고, b기능을 호출할 수도 있음
- 다형성의 본질
    - 실행시점에 객체 인스턴스를 유연하게 변경 가능
    - 클라이언트를 변경하지 않고 서버의 본질을 변경 가능
### 정리
- 실세계의 역할과 구현이라는 편리한 컨셉을 통해서 다형성을 객체 세상으로 가져올 수 있음
- 유연하고 변경 용이
- 확장 가능
- 클라이언트에게 영향 안줌
### 한계
- 역할(인터페이스) 자체가 변하면 모두에 영향을 미침(자동차 -> 비행기)
- 인터페이스를 안정적으로 잘 설계해야 변경이 적음
### 스프링과 객체 지향
- 다형성이 가장 중요
- 스프링은 다형성을 극대화해서 이용할 수 있도록 도와줌
- 스프링에서 이야기하는 제어의 역전(IoC), 의존 관계 주입(DI)는 다형성을 활용해서 역할과 구현을 편하게 다룰 수 있도록 지원
- 스프링은 레고 블럭 조립하듯
- 객체지향의 설계 5가지 원칙도 알아야함(SOLID)

## 1-4 좋은 객체지향의 원칙 5가지 SOLID
- 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리해둔것이 SOLID 임
### 단일 책임위 원칙(SRP - Single responsibility principle)
- 한 클래스는 하나의 책임만 가져야함
- 하나의 책임이라는 것은 모호할 수 있다
    - 클수도 있고, 작을수도 있고, 문맥과 상황에 따라 다름
- 중요한 기준은 변경이라고 보면 됨. 변경이 있을 때 파급 효과가 적으면 잘 따른것이라고 보면 된다.
### 개방-폐쇄 원칙 (OCP - Open/closed principle) 가장 중요
- 소프트웨어는 확장에는 열려있으나 변경에는 닫혀있어야함
- 다형성을 활용한다.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 예시로 보여준 memberService 의 문제점
    - 구현 객체를 변경하려면 클라이언트 코드를 변경해야함
    - memberservice 클라이언트가 구현 클래스를 직접 골라야함
    - OCP 원칙을 지킬 수 없음
    - 객체를 생성하고, 연관 관계를 맺어주는 별도의 조립, 설정자가 필요(이걸 스프링이 해줌)
- 말로 설명해선 절대 이해 안가는 부분임
### 리스코프 치환 원칙 (LSP - Liskov substitution principle)
- 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다
- 예를 들어 엑셀을 밟으면 무조건 앞으로 가야한다 라는 법이 있으면 무조건 지켜야한다는 것
### 인터페이스 분리 원칙(ISP - Interface segregation principle)
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 자동차 인터페이스 -> 운전, 정비 인터페이스 분리
- 사용자 클라이언트 -> 운전자, 정비사 클라이언트 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지않음
### 의존관계 역전 원칙(DIP - Dependency inversion principle) 이것도 중요
- 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다.
- 클라이언트 코드가 구현 클래스에 의존하지 않고 인터페이스만 의존해야함
- 역활에 의존해야한다는 것
- 사용하는 인터페이스가 뭔 클래스에 의존하는지 이런건 중요하지 않고 그 인터페이스를 사용하는 것에만 의존하면 되는 것
- 앞에 memberService는 인터페이스뿐만 아니라 인터페이스 내부에서 사용하는 클래스에도 의존하기 때문에 이 원칙을 위반하는 것
### 정리
- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발 불가
- 다형성 만으로는 클라이언트 코드도 함께 변경된다
- 다형성 만으로는 OCP와 DIP를 지킬 수 없음
- 다형성 뿐만 아니라 더 필요

## 1-5 객체지향 설계와 스프링
### 스프링에서 왜 객체 지향 이야기가 나오는가
- 스프링은 다음 기술로 다형성 + OCP,DIP를 가능하게 지원
    - DI : 의존관계, 의존성 주입
    - DI 컨테이너 제공
### 스프링 없던 시절로
- 옛날엔 위같은 원칙을 다지키려면 배보다 배꼽이 중요함
### 정리
- 모든 설계에 역할과 구현을 분리
- 자동차, 공연의 예를 떠올려보면? - 배역은 정해두고 배우는 언제든지 유연하게 변경 가능
- 이상적으론 모든 설계에 인터페이스를 부여하는게 좋음
- 이상적으론 인터페이스를 도입하는게 좋지만 추상화라는 비용이 발생(클래스 만들고, 코드를 한번 더 열어봐야함)
- 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고, 향후 꼭 리팩터링을 해서 인터페이스를 도입하는 것도 한가지 방법임
- 책추천
    - 객체지향 책 추천 : 객체지향의 사실과 오해
    - 스프링 책 추천 : 토비의 스프링
    - JPA 책 추천 : 자바 ORM 표준 JPA 프로그래밍

## 2-1. 프로젝트 생성
- 순수한 자바로 프로젝트를 진행해볼 것
- SPRING BOOT 스타터 사이트로 이동해서 스프링 프로젝트를 생성(https://start.spring.io) -> 나중에 스프링으로 바꾸기 편하게
- 의존은 아무것도 안넣기 때문에 스프링 핵심 라이브러리들만 포함될 것
## 2-2. 비즈니스 요구사항과 설계
### 회원
- 회원을 가입하고 조회할 수 있다
- 회원은 일반과 vip 두가지 등급 존재
- 회원 데이터는 자체 db를 구축할 수 있고, 외부 시스템과 연동할 수 있다.(미확정)
### 주문과 할인 정책
- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다
- 할인 정책은 모든 vip는 1000원을 할인해주는 고정 금액 할인을 적용
- 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 있다.(미확정)
### 방법
- 인터페이스를 만들고 구현체를 언제든지 갈아 낄 수 있도록 설계하면 됨
## 2-3. 회원 도메인 설계
### 회원 도메인 요구사항
- 회원을 가입하고 조회할 수 있다
- 회원은 일반과 vip 두가지 등급 존재
- 회원 데이터는 자체 db를 구축할 수 있고, 외부 시스템과 연동할 수 있다.(미확정)
### 설계
- 스프링 핵심원리 pdf 에 6페이지부터 참고
## 2-4. 회원 도메인 개발
## 2-5. 회원 도메인 실행과 테스트
- 코드 개발(member package)
## 2-6. 주문과 할인 도메인 설계
### 주문과 할인 도메인 요구사항
- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다
- 할인 정책은 모든 vip는 1000원을 할인해주는 고정 금액 할인을 적용
- 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 있다.(미확정)
### 설계
- 스프링 핵심원리 pdf 에 13p 부터 참고
## 2-7. 주문과 할인 도메인 개발
## 2-8. 주문과 할인 도메인 실행과 테스트
- 코드 개발 (order package)
## 3-1. 새로운 할인 정책 개발
- 새로운 할인정책을 적용할 것(고정할인 -> 정률할인)
## 3-2. 새로운 할인 정책 적용과 문제점
- 우리가 했던 방법으로 하면 구현부분을 수정을 해줘야함(FixDiscountPolicy -> RateDiscountPolicy)
- 의존관계가 있으면 수정해야하는 불상사가 발생함
- 누군가 클라이언트 대신 구현 객체를 생성하고 주입해줘야 해결할 수 있음
## 3-3. 관심사의 분리
- 지금까지 우리가 구현한 것은 로미오 역할을 하는 객체가 줄리엣 역할을 하는 객체를 초빙하는 것과 같은 방식임
- 앱의 전체 동작 방식을 구성하기 위해서 구현 객체를 생성하고 연결하는 별도의 클래스를 생성한다.(AppConfig.java를 만들어서)
- 이렇게하면 자기의 일만 하면 된다(실행만)
- 의존관계를 마치 외부에서 주입해주는 것 같은 느낌을 줌(의존관계 주입(DI))
## 3-4. AppConfig 리팩터링
- 우리가 만든 AppConfig는 중복이 있고 역할에 따른 구현이 잘 안보임
- 레포지토리나 할인정책도 중복을 제거하고 역할과 구현 클래스가 한눈에 보이도록 변경
## 3-5. 새로운 구조와 할인 정책 적용
- 이제 고정할인에서 정률할인으로 바꿔볼 것임
- appconfig 코드만 바꿔주면 된다.
- 앱을 실행해보면 정책이 바뀐것을 알 수 있음
- 구성영역이 역할을 담당하는 설정을 모두 통제한다고 보면 된다
## 3-6. 전체 흐름 정리
- 새로운 할인 정책 개발은 문제가 없음
- 적용에는 DIP 위반으로 문제가 있음
- 관심사의 분리를 통해서 해결(지정하는 책임을 담당하는 AppConfig 파일을 생성)
- appconfig 파일만 수정하면 할인 정책을 변경하는데는 많은 변경이 필요하지 않게되었음
## 3-7. 좋은 객체 지향 설계의 5가지 원칙의 적용
### SRP
- 구현객체는 구현만 하고, 연결하는 책임은 APPCONFIG가 하도록 함
### DIP
- 객체에 대한 의존 관계를 외부에서 넣도록 해주었음(AppConfig)
### OCP
- 소프트웨어 요소확장은 열려있음(다른 할인 정책으로 확장)
- 변경은 닫혀있음(AppConfig만 바꾸고 클라이언트 코드는 바꾸지 않아도 되었음)
## 3-8. IoC, DI, 그리고 컨테이너
### IoC 제어의 역전
- 기존 프로그램은 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고 실행했었는데 AppConfig가 등장하면서 프로그램의 제어 흐름 자체를 AppConfig가 갖게되었음
- 호출하는 제어를 프레임워크에게 넘기는 것 이것을 제어의 역전이라고 함
- 프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 프레임워크가 맞음(junit)
- 내가 작성한 코드가 직접 흐름을 제어한다면 그건 라이브러리지 프레임워크가 아님
### DI 의존관계 주입
- 정적인 클래스 의존관계와 동적인 클래스 의존관계가 존재함
- 정적인 클래스 의존관계는 IMPORT된 클래스들만 보고도 의존관계를 알 수 있고 변하지도 않음(애플리케이션을 수행하지 않아도 의존관계를 알 수 있음)
- 동적인 클래스 의존 관계는 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 타입 인스턴스를 변경할 수 있음, 실행하지 않으면 의존관계를 알 수 없음
### IoC, DI, 컨테이너
- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC컨테이너 또는 DI 컨테이너라고 함
- 최근에는 보통 DI 컨테이너라고 부름
## 3-9. 스프링으로 전환하기
- 코드 수정
- ApplicationContext를 스프링 컨테이너라고 부름
- 스프링 컨텍스트에 @Bean 어노테이션을 통해서 등록함
- 이걸 스프링 빈이라고 부름
- 이제는 빈 컨테이너를 통해서 우리가 필요한 메서드를 찾아서 사용하면 됨
- 자바에선 우리가 다 해줬다면 이제는 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 바뀐것
- 코드가 약간 더 복잡해보이기도 함(스프링 컨테이너가 관리해줌으로써 할 수 있는게 어마어마하게 많음)
## 4-1. 스프링 컨테이너 생성
- ApplicationContext를 우리는 보통 스프링 컨테이너라고 부름
- 이 스프링 컨테이너는 인터페이스임
- 스프링 컨테이너는 
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); 이런식으로 생성
- 생성자의 변수로 스프링 컨테이너에 등록할 구성정보를 담은 컨테이너를 넣어주면 된다
- BeanFactory랑 ApplicationContext가 스프링 컨테이너인데 전자는 잘 안사용하니까 후자가 스프링 컨테이너라고 생각하면 된다.
- 빈 이름은 항상 다르게 부여해야함!
- 실무에서는 무조건 단순하고 명확하게!
- 스프링 부트에서는 빈 이름이 중복되면 경고를 날려주고 팅겨버림
- 스프링 컨테이너는 설정 정보를 참조해서 의존관계를 주입함
- 스프링 빈 등록 - 스프링 빈 의존관계 설정
- 스프링은 빈을 등록하고 의존관계를 설정해주는 단계가 나뉘어져있어서 두단계로 실행된다(이유는 추후에 나옴)
## 4-2. 컨테이너에 등록된 모든 빈 조회
- hello.core.beanfind에 ApplicationContextInfoTest.java 확인
## 4-3. 스프링 빈 조회 - 기본
- 빈을 조회하는 가장 기본적인 방법은 ac.getBean(빈이름, 타입), ac.getBean(빈이름)으로 하면 된다.
- hello.core.beanfind에 ApplicationContextBasicFindTest.java
## 4-4. 스프링 빈 조회 - 동일한 타입이 둘 이상
- 스프링 빈을 타입으로 조회시 동일한 타입이 두개 이상 빈으로 등록되어있을 경우 NoUniqueBeanDefinitionException에러가 나옴
- hello.core.beanfind에 ApplicationContextSameBeanFindTest.java
## 4-5. 스프링 빈 조회 - 상속 관계
- 부모 타입으로 조회시 자식 타입들은 다 끌려나와서 보인다고 보면 된다(자동 의존관계 주입 배울 때 중요)
- 자바의 모든 객체의 최고 부모인 Object타입으로 조회하면 모든 스프링 빈을 조회함
- hello.core.beanfind에 ApplicationContextExtendsFindTest.java
- 실제 개발할 때에는 빈을 조회할 일이 별로 없긴함
- 그냥 기본 기능이니까 해보는 것
## 4-6. BeanFactory와 ApplicationContext
### BeanFactory
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역할을 담당
- 지금까지 우리가 사용했던 대부분의 기능은 BeanFactory의 기능임
### ApplicationContext
- BeanFactory의 모든 기능을 상속받아서 제공함
- 애플리케이션을 개발할 때는 빈은 관리하고 조회하는 기능은 물론 많은 부가기능이 필요한데 이걸 애플리케이션 컨텍스트에서 지원해줌
- 메시지 소스를 활용한 국제화 기능
    - 국가마다 사용하는 언어로 출력
- 환경변수
    - 로컬, 개발, 운영등을 구분해서 처리
- 애플리케이션 이벤트
    - 이벤트를 발행하고 구독하는 모델을 편리하게 지원
- 편리한 리소스 조회
    - 파일, 클래스패스, 외부 등에서 리소스를 편하게 조회
- 따라서 빈 팩토리는 거의 사용할 일이 없음
## 4-7. 다양한 설정 형식 지원 - 자바 코드, xml
- 스프링은 다양한 형식의 설정정보를 받아서 유연하게 사용할 수 있도록 설계되어있음(자바코드, xml, groovy 등)
- 요즘은 어노테이션 기반 자바 코드 설정을 사용
- 예전에는 xml을 많이 사용했었음
- xml은 스프링부트로 넘어가면서 거의 사용되지 않으나 그 이전에 구현된 프로젝트들은 xml을 사용하는 경우도 있음(레거시)
- xml도 빈이랑 똑같은데 그냥 파일 타입만 다른거임
## 4-8. 스프링 빈 설정 메타 정보 - BeanDefinition
- beandefinition이라는 추상화가 있어서 스프링이 다양한 설정 방식을 지원하는 것
- 스프링은 xml인지 자바인지는 보지 않고 BeanDefinition만 알고있으면 된다
- BeanDefinition을 빈 설정 메타정보라고 하며 @Bean, <bean>당 각각 메타 정보
- 빈 메타정보를 바탕으로 스프링 빈을 생성함
- BeanDefinition을 직접 설정할 일은 없으므로 모르고 넘어가도 상관은 없다
## 5-1. 싱글톤 컨테이너 - 웹 애플리케이션과 싱글톤
- 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생
- 대부분의 스프링 어플리케이션은 웹 어플리케이션임
- 하지만 데몬이나 배치 어플리케이션을 못만드는 것은 아님
- 우리가 만들 어플리케이션은 고객이 요청이 올때마다 객체가 생성하는 문제가 존재
- 스프링 없는 순수한 di컨테이너는 appconfig가 요청될때마다 객체를 새로 생성함(메모리 낭비 심함)
- 객체를 하나만 생성해놓고 생성된 인스턴스를 공유해서 사용하도록 설계(싱글톤 패턴)
- 
## 5-2. 싱클톤 컨테이너 - 싱글톤 패턴
- 싱글톤 패턴은 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴임
- 객체 인스턴스를 2개이상 생성하지 못하도록 막아야함
    - private 를 사용하여 생성자에 접근하지 못하도록 하면 된다.
- 생성자를 PRIVATE로 선언해두면 이 객체 인스턴스가 필요하면 오직 getInstance()메서드만 사용해서 접근 가능하도록 하면 된다(외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막음)
- hello.core.singleton에 SingletonTest.java
- 스프링에서는 알아서 싱글톤으로 관리해줌
### 싱글톤의 단점
- 코드 자체가 길어짐
- 의존관계상 클라이언트가 구체 클래스에 의존한다(dip 위반)
- 클라이언트가 구체 클래스에 의존해서 ocp를 위반하 가능성이 높음
- 테스트가 어려움
- 내부 속성을 변경하거나 초기화 하기 어려움
- private 생성자로 자식 클래스를 만들기 어려움
- 결론 : 유연성이 떨어짐
- 안티패턴으로 불리기도 함
## 5-3. 싱글톤 컨테이너 - 싱글톤 컨테이너
- 스프링 커테이너는 싱글톤 패턴을 적용하지 않아도 싱글톤으로 관리해줌
- 싱글톤 컨테이너를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 함
- 스프링 컨테이너의 이런 기능으로 인해 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있음
    - 지저분한 코드 x
    - dip, ocp, 테스트, private 생성자로 부터 자유롭게 싱글톤 사용 가능
- test.java.hello.core.singleton SingletonTest.java 에 springContainer 테스트 부분
- 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라 이미 생성된 객체를 공유해서 효율적으로 재사용 가능
- 스프링에서도 싱글톤 말고 다른 것들도 제공하기는 함
## 5-4. 싱글톤 컨테이너 - 싱글톤 방식의 주의점
- 싱글톤 패턴은 객체 상태를 유지하게 설계하면 안됨
- 무상태로 설계해야함
    - 특정 클라이언트에 의존적인 필드가 있으면 안됨
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다
    - 가급적 읽기만 하도록 해야함
- 스프링 빈의 필드에 공유 값을 설정하면 큰 장애 발생가능
- 공유 필드를 변경하면 조회시 문제 생길 수 있음
- test.java.hello.core.singleton StatefulService.java, StatefulServiceTest.java 참고
- 그렇기에 무상태로 짭시다
## 5-5. 싱글톤 컨테이너 - @Configuration과 싱글톤
- 우리 Appconfig보면 싱글톤이 깨지는 것처럼 보임
- memberService와 orderService가 둘다 memberRepository()를 호출해서 new MemoryMemberRepository()를 호출하기 때문이다
- 근데 스프링 컨테이너는 이 문제를 해결해준다
- 어떻게?(다음장)
## 5-6. 싱글톤 컨테이너 - @Configuration과 바이트코드 조작의 마법
- memberRepository는 왜 한번만 호출되었을까?
- 스프링 컨테이너는 싱글톤 레지스트리다(스프링 빈이 싱글톤이 되도록 보장)
- 스프링이 자바 코드까지 어떻게 하기는 어렵기때문에 원래대로라면 분명 memberRepository가 3번 호출되는 게맞음
- 하지만 이건 @Configuration을 적용한 AppConfig때문에 1번만 호출되는 것임
- 스프링이 내가 만든 클래스를 만드는 것이 아닌 AppConfig 클래스를 상속받은 CGLIB라는 바이트코드 조작 라이브러리를 사용하여 다른 클래스를 만들고 그 클래스를 스프링 빈으로 등록한것임
- 이 임의로 생성된 클래스가 싱글톤을 보장해주는 것임
- @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고 없다면 생성해서 스프링 빈으로 등록해주는 코드가 동적으로 만들어짐
- 그렇다면 @Configuration을 안붙이면?
    - 총 3번 호출하게 된다
## 6-1. 컴포넌트 스캔과 의존관계 자동 주입 시작하기
- 실무에서는 수십, 수백개의 빈을 일일이 등록해야하면 귀찮고 누락하는 문제도 발생
- 그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔을 제공
- 의존 관계도 자동으로 주입해주는 @Autowired도 지원함(생성자 바로 앞에 씀)
- @Configuration이 붙은 설정 정보도 자동으로 등록되기때문에 이런것들은 예외처리 해주는게 좋음(보통 실무에서는 예외할일이 별로 없긴함)
- @Configuration도 까보면 @Component가 선언되어있음
- @Component랑 @AutoWired는 세트라고 보면 됨(자동으로 빈 등록해주고 자동으로 의존관계를 주입해줘야하기때문에)
- AutoAppConfig.java, AutoAppConfigTest.java
## 6-2. 탐색 위치와 기본 스캔 대상
- 컴포넌트 스캔의 기본 탐색 위치를 지정해줄 수 있음
    - basePackages = "hello.core.member" 이런식으로
- {}로 여러개를 시작위치로 지정 가능
- 만약 위치를 지정하지 않으면 @ComponentScan이 붙은 패키지 위치가 시작 위치가 된다.
- 스프링 부트를 쓰면 알아서 다 해주긴함
- 컴포넌트 스캔은 여러 어노테이션을 대상에 포함함
    - @Component
    - @Controller
    - @Service
    - @Repository
    - @Configuration
- 어노텍이션이 특정 어노테이션을 들고 있는 것을 인식할 수 있는 것은 자바가 지원하는게 아니라 스프링이 지원하는거임
- @Controller : 스프링 MVC 컨트롤러로 인식
- @Repository : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
- @Configuration : 앞서 보았듯이 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가
처리를 한다.
- @Service : 사실 @Service 는 특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나 라고 비즈니스 계층을 인식하는데 도움이 된다
## 6-3. 필터
- 필터 조건은 5가지 옵션이 있음
    - ANNOTATION: 기본값, 애노테이션을 인식해서 동작한다.
        ex) org.example.SomeAnnotation
    - ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
        ex) org.example.SomeClass
    - ASPECTJ: AspectJ 패턴 사용
        ex) org.example..*Service+
    - REGEX: 정규 표현식
        ex) org\.example\.Default.*
    - CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리
        ex) org.example.MyTypeFilte
## 6-4. 중복 등록과 충돌
### 자동빈 등록과 자동빈 등록 충돌
- ConflictingBeanDefinitionException 예외 발생
### 수동빈 등록과 자동빈 등록 충돌
- 수동빈 등록이 우선권을 갖는다
- 수동빈이 자동빈을 오버라이딩 해버림
- 현실은 개발자 의도와 다르게 여러 설정들이 꼬여서 이런 결과가 나오는 경우가 대부분임
- 말도 안되는 이상한 버그 발생함
- 그래서 최근 스프링 부트에서는 수동빈과 자동빈이 충돌하면 에러 발생하도록 바뀜
    - spring.main.allow-bean-definition-overriding=true 를 프로퍼티에 넣으면 충돌 에러 발생하지 않고 수동빈이 자동빈 오버라이딩  