# 스프링 핵심원리 - 기본편
## 1-1. 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생
- EJB는 예전에 금융권같은데서 표준으로 많이 도입함.
- EJB는 분산에 대한 지원이 잘되었었음
- JPA는 ORM 기술, EJB는 Entity bin 이라는 orm 기술을 가지고 있었음
- ORM기술은 쿼리 안쓰고 DB에 접근해서 데이터 넣고빼고
- 근데 EJB는 이론적으로 굉장히 좋으나 비쌈
- 심지어 복잡한데 어렵고 EJB에 의존적으로 개발해야하는 치명적인 단점이 있음(지옥임)
- EJB는 컨테이너 하나 띄우는데도 시간 엄청 오래걸림
- EJB가 너무 개떡같았기 때문에 POJO로 돌아가자라는 소리까지 나옴
- 그래서 만들어진 것이 스프링이다
- EJB의 엔티티빈이 너무 꾸져서 하이버네이트를 만들었는데 이것이 자바 표준을 만드는 곳에서 하이버네이트를 가지고 JPA를 만들었음
- JPA가 자바 진형의 ORM을 다 먹고있음
- JPA는 실용성과 표준의 안정성을 만족 시킬 수 있게되었음
### 스프링의 역사
- 2002년 로드 존슨이 EJB의 문제점을 지적하면서 EJB없이도 충분히 고품질의 확장 가능한 애플리케이션을 3만라인 이상의 기반 코드를 보여줌으로써 혁신을 일으킴(스프링의 시작)
- 로드 존슨에게 유겐휠러와 얀 카로프가 스프링 오픈소스 프로젝트를 제안했고, 스프링의 핵심 코드는 현재도 유겐 휠러가 개발 중
- 스프링의 뜻은 J2EE(EJB)라는 겨울을 넘어 새로운 시작이라는 뜻으로 지음
- 스프링 릴리즈 역사
    - 2003년 스프링 프레임워크 1.0 출시 - XML
    - 2006년 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원
    - 2009년 스프링 프레임워크 3.0 출시 - 자바 코드로 설정
    - 2013년 스프링 프레임워크 4.0 출시 - 자바 8
    - 2014년 스프링 부트 1.0 출시 - 설정이 너무 어려운 스프링의 단점을 개선, 설정을 거의 할 필요없고 서버도 내장
    - 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 - 리엑티브 프로그래밍 지원
    - 현재 진행 중

## 1-2. 스프링이란
### 스프링 생태계
- 스프링 프레임워크, 스프링 부트, 스프링 데이터(데이터베이스 쉽게 접근), 스프링 세션(세션관련), 스프링 시큐리티(보안), 스프링 REST DOCS, 스프링 배치(배치처리에 특화된 기술), 스프링 클라우드(클라우드 관련 기술)
- spring.io에 프로젝트 오버뷰를 보면 어떤 기술이 무슨 역할을 하는지 다 나와있음
### 스프링 프레임워크
- 핵심기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹기술 : 스프링 MVC, 스프링 WebFlux 
- 등등
- 핵심기술에 초점을 맞춰서 강의 할 것
### 스프링 부트
- 단독으로 실행할 수 있는 스프링 어플리케이션을 쉽게 생성
- tomcat 같은 웹 서버를 내장해서 별도 웹 서버 설치 안해도 됌
- 손쉬운 빌드 구성을 위한 starter 종속성 제공(라이브러리 쓸때 필요한걸 starter가 알아서 다 땡겨와줌)
- 스프링과 3rd parth 라이브러리 자동 구성(메이저 라이브러리는 어떤게 지금 스프링 버전에 맞는지 알아서 다 챙겨줌)
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공(모니터링 화면 제공)
- 관례에 의한 간결한 설정(꼭 필요할 때에만 설정을 바꿈)
- 스프링 부트는 기본적으로 스프링 프레임워크를 가져와서 해주는 거지 껍데기라 혼자서는 동작 불가
### 스프링 단어
- 스프링이라는 단어는 문맥에 따라 다르게 사용된다.
    - 스프링 DI 컨테이너 기술
    - 스프링 프레임워크
    - 스프링 부트, 스프링 프레임워크 등을 모두 포함하는 포괄적인 단어
### 스프링은 왜 만들었나
- 핵심 개념을 알아야 배우기 쉬움
- 스프링의 핵심 개념, 컨셉?
    - 웹 앱을 만들고 DB 접근 편리하게 해주는 기술인가?
    - 전자정부 프레임워크?
    - ???
- 스프링의 진짜 핵심
    - 스프링은 자바 기반의 프레임워크
    - 자바 언어의 가장 큰 특징 - 객체 지향 언어적 장점을 살려서 개발 할 수 있도록 도와줌
    - 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
    - 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있도록 도와주는 프레임워크 !!

## 1-3 좋은 객체지향 프로그래밍이란?
### 객체 지향 프로그래밍
- 컴퓨터 프로그램을 객체들의 모임으로 파악하고 그에 맞게 개발
- 객체지향 프로그래밍은 유연하고 변경이 용이하게 만듬
- 객체간에 메시지를 주고받고 서로 협력함
- 유연하고 변경이 용이하다?
    - 레고 블럭 조립하듯
    - 키보드 마우스를 갈아끼우듯
    - 다형성이 핵심이라고 보면 된다
### 다형성
- 다형성의 실세계 비유
    - 실세계와 객체지향을 1:1로 매칭X
    - 역할과 구현으로
- 운전자 - 자동차
    - 자동차가 K3에서 아반떼로 바뀌어도 운전자는 운전할 수 있다(자동차가 바뀌어도 운전자에게 영향을 미치지 않는다)
    - 운전자는 자동차 역할(인터페이스)에 대해서만 알고 자동차 구현(차종)은 모름
    - 다른 대상으로 변환이 가능하고 새로운 것이 나와도 영향을 미치지 않음(클라이언트에 영향을 주지 않고 새로운 기능을 제공 가능)
- 새로운 기능이 나와도 클라이언트를 바꿀 필요가 없다! 이게 제일 중요함
- 공연 무대
    - 로미오 역할과 줄리엣 역할이 있다
    - 이 로미오 역할을 장동건이 할수도 원빈이 할수도 있고, 줄리엣 역할은 김태희가 할수도 있고 송혜교가 할수도 있다
    - 역할을 하는 사람은 바뀌어도 상관 없음
    - 역할과 구현이 따로 분리되어있음!
### 역할과 구현을 분리
- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경이 편해짐
- 장점
    - 클라이언트는 대상의 역할(인터페이스)만 알면 된다
    - 클라이언트는 내부 구조를 몰라도 된다
    - 클라이언트는 내부 구조가 변경되도 영향을 받지 않음
    - 클라이언트는 구현 대상 자체가 변경되도 영향을 받지 않음
- 자바언어의 다형성을 활용
    - 역할 = 인터페이스
    - 구현 = 인터페이스를 구현한 클래스, 구현 객체
    - 객체를 설계할 때 역할과 구현을 명확히 분리
    - 객체 설계시 인터페이스를 먼저 부여하고 구현
### 객체의 협력이라는 관계부터 생각
- 혼자 있는 객체는 없음
- 클라이언트는 요청, 서버는 응답
- 수많은 객체 클라이언트와 서버가 서로 협력관계를 가짐
- 클라이언트는 서버가 될수도 있음
### 자바 언어의 다형성
- 오버라이딩을 떠올려보자
    - 오버라이딩은 자바 기본 문법
    - 오버라이딩 된 메서드가 실행
    - 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능
    - 클래스 상속 관계에서도 다형성, 오버라이딩 삽가능
- 예시
    - 클라이언트가 멤버Repository를 사용한다고 할때 다형성을 이용하여 memory memberrepository의 기능을 쓸수도 있고 jdbc memberrepository 사용 가능
    - 클라이언트가 서버의 a기능을 호출할 수도 있고, b기능을 호출할 수도 있음
- 다형성의 본질
    - 실행시점에 객체 인스턴스를 유연하게 변경 가능
    - 클라이언트를 변경하지 않고 서버의 본질을 변경 가능
### 정리
- 실세계의 역할과 구현이라는 편리한 컨셉을 통해서 다형성을 객체 세상으로 가져올 수 있음
- 유연하고 변경 용이
- 확장 가능
- 클라이언트에게 영향 안줌
### 한계
- 역할(인터페이스) 자체가 변하면 모두에 영향을 미침(자동차 -> 비행기)
- 인터페이스를 안정적으로 잘 설계해야 변경이 적음
### 스프링과 객체 지향
- 다형성이 가장 중요
- 스프링은 다형성을 극대화해서 이용할 수 있도록 도와줌
- 스프링에서 이야기하는 제어의 역전(IoC), 의존 관계 주입(DI)는 다형성을 활용해서 역할과 구현을 편하게 다룰 수 있도록 지원
- 스프링은 레고 블럭 조립하듯
- 객체지향의 설계 5가지 원칙도 알아야함(SOLID)

## 1-4 좋은 객체지향의 원칙 5가지 SOLID
- 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리해둔것이 SOLID 임
### 단일 책임위 원칙(SRP - Single responsibility principle)
- 한 클래스는 하나의 책임만 가져야함
- 하나의 책임이라는 것은 모호할 수 있다
    - 클수도 있고, 작을수도 있고, 문맥과 상황에 따라 다름
- 중요한 기준은 변경이라고 보면 됨. 변경이 있을 때 파급 효과가 적으면 잘 따른것이라고 보면 된다.
### 개방-폐쇄 원칙 (OCP - Open/closed principle) 가장 중요
- 소프트웨어는 확장에는 열려있으나 변경에는 닫혀있어야함
- 다형성을 활용한다.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 예시로 보여준 memberService 의 문제점
    - 구현 객체를 변경하려면 클라이언트 코드를 변경해야함
    - memberservice 클라이언트가 구현 클래스를 직접 골라야함
    - OCP 원칙을 지킬 수 없음
    - 객체를 생성하고, 연관 관계를 맺어주는 별도의 조립, 설정자가 필요(이걸 스프링이 해줌)
- 말로 설명해선 절대 이해 안가는 부분임
### 리스코프 치환 원칙 (LSP - Liskov substitution principle)
- 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다
- 예를 들어 엑셀을 밟으면 무조건 앞으로 가야한다 라는 법이 있으면 무조건 지켜야한다는 것
### 인터페이스 분리 원칙(ISP - Interface segregation principle)
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 자동차 인터페이스 -> 운전, 정비 인터페이스 분리
- 사용자 클라이언트 -> 운전자, 정비사 클라이언트 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지않음
### 의존관계 역전 원칙(DIP - Dependency inversion principle) 이것도 중요
- 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다.
- 클라이언트 코드가 구현 클래스에 의존하지 않고 인터페이스만 의존해야함
- 역활에 의존해야한다는 것
- 사용하는 인터페이스가 뭔 클래스에 의존하는지 이런건 중요하지 않고 그 인터페이스를 사용하는 것에만 의존하면 되는 것
- 앞에 memberService는 인터페이스뿐만 아니라 인터페이스 내부에서 사용하는 클래스에도 의존하기 때문에 이 원칙을 위반하는 것
### 정리
- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발 불가
- 다형성 만으로는 클라이언트 코드도 함께 변경된다
- 다형성 만으로는 OCP와 DIP를 지킬 수 없음
- 다형성 뿐만 아니라 더 필요

## 1-5 객체지향 설계와 스프링
### 스프링에서 왜 객체 지향 이야기가 나오는가
- 스프링은 다음 기술로 다형성 + OCP,DIP를 가능하게 지원
    - DI : 의존관계, 의존성 주입
    - DI 컨테이너 제공
### 스프링 없던 시절로
- 옛날엔 위같은 원칙을 다지키려면 배보다 배꼽이 중요함
### 정리
- 모든 설계에 역할과 구현을 분리
- 자동차, 공연의 예를 떠올려보면? - 배역은 정해두고 배우는 언제든지 유연하게 변경 가능
- 이상적으론 모든 설계에 인터페이스를 부여하는게 좋음
- 이상적으론 인터페이스를 도입하는게 좋지만 추상화라는 비용이 발생(클래스 만들고, 코드를 한번 더 열어봐야함)
- 기능을 확장할 가능성이 없다면 구체 클래스를 직접 사용하고, 향후 꼭 리팩터링을 해서 인터페이스를 도입하는 것도 한가지 방법임
- 책추천
    - 객체지향 책 추천 : 객체지향의 사실과 오해
    - 스프링 책 추천 : 토비의 스프링
    - JPA 책 추천 : 자바 ORM 표준 JPA 프로그래밍

## 2-1. 프로젝트 생성
- 순수한 자바로 프로젝트를 진행해볼 것
- SPRING BOOT 스타터 사이트로 이동해서 스프링 프로젝트를 생성(https://start.spring.io) -> 나중에 스프링으로 바꾸기 편하게
- 의존은 아무것도 안넣기 때문에 스프링 핵심 라이브러리들만 포함될 것
## 2-2. 비즈니스 요구사항과 설계
### 회원
- 회원을 가입하고 조회할 수 있다
- 회원은 일반과 vip 두가지 등급 존재
- 회원 데이터는 자체 db를 구축할 수 있고, 외부 시스템과 연동할 수 있다.(미확정)
### 주문과 할인 정책
- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다
- 할인 정책은 모든 vip는 1000원을 할인해주는 고정 금액 할인을 적용
- 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 있다.(미확정)
### 방법
- 인터페이스를 만들고 구현체를 언제든지 갈아 낄 수 있도록 설계하면 됨
## 2-3. 회원 도메인 설계
### 회원 도메인 요구사항
- 회원을 가입하고 조회할 수 있다
- 회원은 일반과 vip 두가지 등급 존재
- 회원 데이터는 자체 db를 구축할 수 있고, 외부 시스템과 연동할 수 있다.(미확정)
### 설계
- 스프링 핵심원리 pdf 에 6페이지부터 참고
## 2-4. 회원 도메인 개발
## 2-5. 회원 도메인 실행과 테스트
- 코드 개발(member package)
## 2-6. 주문과 할인 도메인 설계
### 주문과 할인 도메인 요구사항
- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다
- 할인 정책은 모든 vip는 1000원을 할인해주는 고정 금액 할인을 적용
- 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 있다.(미확정)
### 설계
- 스프링 핵심원리 pdf 에 13p 부터 참고
## 2-7. 주문과 할인 도메인 개발
## 2-8. 주문과 할인 도메인 실행과 테스트
- 코드 개발 (order package)
## 3-1. 새로운 할인 정책 개발
- 새로운 할인정책을 적용할 것(고정할인 -> 정률할인)
## 3-2. 새로운 할인 정책 적용과 문제점
- 우리가 했던 방법으로 하면 구현부분을 수정을 해줘야함(FixDiscountPolicy -> RateDiscountPolicy)
- 의존관계가 있으면 수정해야하는 불상사가 발생함
- 누군가 클라이언트 대신 구현 객체를 생성하고 주입해줘야 해결할 수 있음
## 3-3. 관심사의 분리
- 지금까지 우리가 구현한 것은 로미오 역할을 하는 객체가 줄리엣 역할을 하는 객체를 초빙하는 것과 같은 방식임
- 앱의 전체 동작 방식을 구성하기 위해서 구현 객체를 생성하고 연결하는 별도의 클래스를 생성한다.(AppConfig.java를 만들어서)
- 이렇게하면 자기의 일만 하면 된다(실행만)
- 의존관계를 마치 외부에서 주입해주는 것 같은 느낌을 줌(의존관계 주입(DI))
## 3-4. AppConfig 리팩터링
- 우리가 만든 AppConfig는 중복이 있고 역할에 따른 구현이 잘 안보임
- 레포지토리나 할인정책도 중복을 제거하고 역할과 구현 클래스가 한눈에 보이도록 변경
## 3-5. 새로운 구조와 할인 정책 적용
- 이제 고정할인에서 정률할인으로 바꿔볼 것임
- appconfig 코드만 바꿔주면 된다.
- 앱을 실행해보면 정책이 바뀐것을 알 수 있음
- 구성영역이 역할을 담당하는 설정을 모두 통제한다고 보면 된다
## 3-6. 전체 흐름 정리
- 새로운 할인 정책 개발은 문제가 없음
- 적용에는 DIP 위반으로 문제가 있음
- 관심사의 분리를 통해서 해결(지정하는 책임을 담당하는 AppConfig 파일을 생성)
- appconfig 파일만 수정하면 할인 정책을 변경하는데는 많은 변경이 필요하지 않게되었음
## 3-7. 좋은 객체 지향 설계의 5가지 원칙의 적용
### SRP
- 구현객체는 구현만 하고, 연결하는 책임은 APPCONFIG가 하도록 함
### DIP
- 객체에 대한 의존 관계를 외부에서 넣도록 해주었음(AppConfig)
### OCP
- 소프트웨어 요소확장은 열려있음(다른 할인 정책으로 확장)
- 변경은 닫혀있음(AppConfig만 바꾸고 클라이언트 코드는 바꾸지 않아도 되었음)
## 3-8. IoC, DI, 그리고 컨테이너
### IoC 제어의 역전
- 기존 프로그램은 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고 실행했었는데 AppConfig가 등장하면서 프로그램의 제어 흐름 자체를 AppConfig가 갖게되었음
- 호출하는 제어를 프레임워크에게 넘기는 것 이것을 제어의 역전이라고 함
- 프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 프레임워크가 맞음(junit)
- 내가 작성한 코드가 직접 흐름을 제어한다면 그건 라이브러리지 프레임워크가 아님
### DI 의존관계 주입
- 정적인 클래스 의존관계와 동적인 클래스 의존관계가 존재함
- 정적인 클래스 의존관계는 IMPORT된 클래스들만 보고도 의존관계를 알 수 있고 변하지도 않음(애플리케이션을 수행하지 않아도 의존관계를 알 수 있음)
- 동적인 클래스 의존 관계는 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 타입 인스턴스를 변경할 수 있음, 실행하지 않으면 의존관계를 알 수 없음
### IoC, DI, 컨테이너
- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC컨테이너 또는 DI 컨테이너라고 함
- 최근에는 보통 DI 컨테이너라고 부름
## 3-9. 스프링으로 전환하기
- 코드 수정
- ApplicationContext를 스프링 컨테이너라고 부름
- 스프링 컨텍스트에 @Bean 어노테이션을 통해서 등록함
- 이걸 스프링 빈이라고 부름
- 이제는 빈 컨테이너를 통해서 우리가 필요한 메서드를 찾아서 사용하면 됨
- 자바에선 우리가 다 해줬다면 이제는 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 바뀐것
- 코드가 약간 더 복잡해보이기도 함